{"ast":null,"code":"import jwt from \"jsonwebtoken\";\nimport Mock from \"./mock\";\nconst JWT_SECRET = \"jwt_secret_key\";\nconst JWT_VALIDITY = \"7 days\";\nconst userList = [{\n  id: 1,\n  role: \"SA\",\n  name: \"Jason Alexander\",\n  username: \"jason_alexander\",\n  email: \"demo@example.com\",\n  avatar: \"/static/avatar/001-man.svg\",\n  age: 25 // password: 'v&)3?2]:'\n}];\n\nMock.onPost(\"/api/auth/login\").reply(async config => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const {\n      email\n    } = JSON.parse(config.data);\n    const user = userList.find(user => user.email === email);\n    if (!user) {\n      return [400, {\n        message: \"Invalid email or password\"\n      }];\n    }\n    const accessToken = jwt.sign({\n      userId: user.id\n    }, JWT_SECRET, {\n      expiresIn: JWT_VALIDITY\n    });\n    return [200, {\n      accessToken,\n      user: {\n        id: user.id,\n        avatar: user.avatar,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      }\n    }];\n  } catch (error) {\n    console.error(error);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});\nMock.onPost(\"/api/auth/register\").reply(async config => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const {\n      email,\n      username\n    } = JSON.parse(config.data);\n    const user = userList.find(user => user.email === email);\n    if (user) {\n      return [400, {\n        message: \"User already exists!\"\n      }];\n    }\n    const newUser = {\n      id: 2,\n      role: \"GUEST\",\n      name: \"\",\n      username: username,\n      email: email,\n      avatar: \"/static/avatar/001-man.svg\",\n      age: 25\n    };\n    userList.push(newUser);\n    const accessToken = jwt.sign({\n      userId: newUser.id\n    }, JWT_SECRET, {\n      expiresIn: JWT_VALIDITY\n    });\n    return [200, {\n      accessToken,\n      user: {\n        id: newUser.id,\n        avatar: newUser.avatar,\n        email: newUser.email,\n        name: newUser.name,\n        username: newUser.username,\n        role: newUser.role\n      }\n    }];\n  } catch (error) {\n    console.error(error);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});\nMock.onGet(\"/api/auth/profile\").reply(config => {\n  try {\n    //@ts-ignore\n    const {\n      Authorization\n    } = config.headers;\n    if (!Authorization) {\n      return [401, {\n        message: \"Invalid Authorization token\"\n      }];\n    }\n    const accessToken = Authorization.split(\" \")[1];\n    const {\n      userId\n    } = jwt.verify(accessToken, JWT_SECRET);\n    const user = userList.find(u => u.id === userId);\n    if (!user) {\n      return [401, {\n        message: \"Invalid authorization token\"\n      }];\n    }\n    return [200, {\n      user: {\n        id: user.id,\n        avatar: user.avatar,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      }\n    }];\n  } catch (err) {\n    console.error(err);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});","map":{"version":3,"names":["jwt","Mock","JWT_SECRET","JWT_VALIDITY","userList","id","role","name","username","email","avatar","age","onPost","reply","config","Promise","resolve","setTimeout","JSON","parse","data","user","find","message","accessToken","sign","userId","expiresIn","error","console","newUser","push","onGet","Authorization","headers","split","verify","u","err"],"sources":["/workspaces/v4/client/src/__fakeData__/users.js"],"sourcesContent":["import jwt from \"jsonwebtoken\";\nimport Mock from \"./mock\";\nconst JWT_SECRET = \"jwt_secret_key\";\nconst JWT_VALIDITY = \"7 days\";\nconst userList = [{\n  id: 1,\n  role: \"SA\",\n  name: \"Jason Alexander\",\n  username: \"jason_alexander\",\n  email: \"demo@example.com\",\n  avatar: \"/static/avatar/001-man.svg\",\n  age: 25 // password: 'v&)3?2]:'\n\n}];\nMock.onPost(\"/api/auth/login\").reply(async config => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const {\n      email\n    } = JSON.parse(config.data);\n    const user = userList.find(user => user.email === email);\n\n    if (!user) {\n      return [400, {\n        message: \"Invalid email or password\"\n      }];\n    }\n\n    const accessToken = jwt.sign({\n      userId: user.id\n    }, JWT_SECRET, {\n      expiresIn: JWT_VALIDITY\n    });\n    return [200, {\n      accessToken,\n      user: {\n        id: user.id,\n        avatar: user.avatar,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      }\n    }];\n  } catch (error) {\n    console.error(error);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});\nMock.onPost(\"/api/auth/register\").reply(async config => {\n  try {\n    await new Promise(resolve => setTimeout(resolve, 1000));\n    const {\n      email,\n      username\n    } = JSON.parse(config.data);\n    const user = userList.find(user => user.email === email);\n\n    if (user) {\n      return [400, {\n        message: \"User already exists!\"\n      }];\n    }\n\n    const newUser = {\n      id: 2,\n      role: \"GUEST\",\n      name: \"\",\n      username: username,\n      email: email,\n      avatar: \"/static/avatar/001-man.svg\",\n      age: 25\n    };\n    userList.push(newUser);\n    const accessToken = jwt.sign({\n      userId: newUser.id\n    }, JWT_SECRET, {\n      expiresIn: JWT_VALIDITY\n    });\n    return [200, {\n      accessToken,\n      user: {\n        id: newUser.id,\n        avatar: newUser.avatar,\n        email: newUser.email,\n        name: newUser.name,\n        username: newUser.username,\n        role: newUser.role\n      }\n    }];\n  } catch (error) {\n    console.error(error);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});\nMock.onGet(\"/api/auth/profile\").reply(config => {\n  try {\n    //@ts-ignore\n    const {\n      Authorization\n    } = config.headers;\n\n    if (!Authorization) {\n      return [401, {\n        message: \"Invalid Authorization token\"\n      }];\n    }\n\n    const accessToken = Authorization.split(\" \")[1];\n    const {\n      userId\n    } = jwt.verify(accessToken, JWT_SECRET);\n    const user = userList.find(u => u.id === userId);\n\n    if (!user) {\n      return [401, {\n        message: \"Invalid authorization token\"\n      }];\n    }\n\n    return [200, {\n      user: {\n        id: user.id,\n        avatar: user.avatar,\n        email: user.email,\n        name: user.name,\n        role: user.role\n      }\n    }];\n  } catch (err) {\n    console.error(err);\n    return [500, {\n      message: \"Internal server error\"\n    }];\n  }\n});"],"mappings":"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"},"metadata":{},"sourceType":"module"}